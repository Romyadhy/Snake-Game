<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Snake — Single File Game</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    /* Basic page layout */
    :root{
      --bg:#0b1220;
      --panel:#0f1722;
      --accent:#22c55e;
      --muted:#94a3b8;
      --danger:#ef4444;
    }
    html,body{
      height:100%;
      margin:0;
      font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: linear-gradient(180deg, #071024 0%, #071827 100%);
      color:white;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .container{
      display:flex;
      gap:18px;
      align-items:flex-start;
      padding:20px;
      background:rgba(255,255,255,0.02);
      border-radius:12px;
      box-shadow: 0 6px 30px rgba(2,6,23,0.6);
    }

    /* Canvas styling */
    canvas{
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      border-radius:8px;
      box-shadow: inset 0 2px 8px rgba(255,255,255,0.02), 0 6px 20px rgba(2,6,23,0.6);
      display:block;
    }

    /* Info panel */
    .panel{
      width:220px;
      background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
      padding:14px;
      border-radius:10px;
      box-shadow: 0 6px 20px rgba(2,6,23,0.5);
    }
    .panel h1{
      font-size:18px;
      margin:0 0 8px 0;
      color:var(--accent);
    }
    .row{display:flex;justify-content:space-between;align-items:center;margin:8px 0;}
    .muted{color:var(--muted);font-size:13px}
    .big{font-size:28px;font-weight:700;letter-spacing:1px}
    button{
      width:100%;
      padding:10px 12px;
      border-radius:8px;
      border:0;
      background:var(--accent);
      color:#042014;
      font-weight:700;
      cursor:pointer;
      margin-top:10px;
    }
    .hint{
      margin-top:10px;
      font-size:13px;
      color:var(--muted);
      line-height:1.4;
    }
    .msg{
      margin-top:10px;
      padding:8px;
      border-radius:8px;
      font-size:14px;
      text-align:center;
      display:none;
    }
    .msg.show{display:block;}
    .msg.danger{background:rgba(239,68,68,0.12); color:var(--danger); border:1px solid rgba(239,68,68,0.12);}
    .msg.ok{background:rgba(34,197,94,0.08); color:var(--accent); border:1px solid rgba(34,197,94,0.06);}
    footer{margin-top:12px;color:var(--muted);font-size:12px;text-align:center}
    @media (max-width:700px){
      .container{flex-direction:column;align-items:center}
      .panel{width:100%}
    }
  </style>
</head>
<body>
  <div class="container" role="application" aria-label="Snake game container">
    <!-- Canvas for rendering the game -->
    <canvas id="gameCanvas" width="640" height="480" aria-label="Snake game canvas"></canvas>

    <!-- Side panel with score and controls -->
    <div class="panel" aria-hidden="false">
      <h1>Snake</h1>
      <div class="row">
        <div class="muted">Score</div>
        <div id="score" class="big">0</div>
      </div>

      <div class="row">
        <div class="muted">Speed</div>
        <div id="speedLabel" class="muted">Normal</div>
      </div>

      <button id="restartBtn" title="Restart game">Start / Restart</button>

      <div id="message" class="msg danger" role="status" aria-live="polite">Game Over</div>

      <div class="hint">
        Controls: Arrow Keys — the snake moves automatically.<br>
        Avoid walls and don't run into yourself.<br>
        Press <strong>Start / Restart</strong> to play.
      </div>

      <footer>Made with ❤️ — Single-file HTML game</footer>
    </div>
  </div>

  <script>
  /****************************************************************
   * Snake Game — Single HTML file
   * Features:
   * - Canvas rendering
   * - Snake moves automatically on a fixed tick
   * - Arrow keys to control (no immediate reverse)
   * - Game over on wall or self-collision
   * - Random food spawn not overlapping snake
   * - Start/Restart button and score display
   ****************************************************************/

  (function(){
    // Canvas & drawing context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    // Grid settings (make sure canvas.width/height are multiples of cell size for tidy grid)
    const CELL_SIZE = 20;               // Pixel size of one grid cell
    const COLS = Math.floor(canvas.width / CELL_SIZE);
    const ROWS = Math.floor(canvas.height / CELL_SIZE);

    // Game timing
    const BASE_TICK_MS = 100;          // Base tick in milliseconds (smaller == faster)
    let tickInterval = BASE_TICK_MS;   // current tick interval (can be adjusted for speed)
    let tickTimer = null;              // reference to interval timer

    // Game state
    let snake = [];                    // array of {x,y} positions (head is first element)
    let dir = { x: 1, y: 0 };          // current direction vector: right initially
    let nextDir = { x: 1, y: 0 };      // queued direction (to avoid multiple immediate turns per tick)
    let food = null;                   // {x,y} food position
    let score = 0;
    let running = false;
    let gameOver = false;

    // UI elements
    const scoreEl = document.getElementById('score');
    const restartBtn = document.getElementById('restartBtn');
    const messageEl = document.getElementById('message');
    const speedLabel = document.getElementById('speedLabel');

    // Helper: create a new snake positioned around the center
    function initSnake(){
      const startLength = 5;
      const startX = Math.floor(COLS / 2);
      const startY = Math.floor(ROWS / 2);
      snake = [];
      for(let i = 0; i < startLength; i++){
        // Place segments to the left so the snake faces right
        snake.push({ x: startX - i, y: startY });
      }
      dir = { x: 1, y: 0 };
      nextDir = { x: 1, y: 0 };
    }

    // Helper: spawn food at a random free cell (not on the snake)
    function spawnFood(){
      let attempts = 0;
      while(true){
        attempts++;
        if(attempts > 10000){
          // extremely unlikely; if grid full, stop trying
          food = null;
          return;
        }
        const fx = Math.floor(Math.random() * COLS);
        const fy = Math.floor(Math.random() * ROWS);
        // Ensure not on snake
        let collide = false;
        for(const s of snake){
          if(s.x === fx && s.y === fy){ collide = true; break; }
        }
        if(!collide){
          food = { x: fx, y: fy };
          return;
        }
      }
    }

    // Reset & start the game
    function startGame(){
      running = true;
      gameOver = false;
      score = 0;
      scoreEl.textContent = score;
      messageEl.classList.remove('show');
      messageEl.classList.remove('danger');
      messageEl.classList.remove('ok');
      initSnake();
      spawnFood();
      // If an old timer exists, clear it
      if(tickTimer) clearInterval(tickTimer);
      tickTimer = setInterval(gameTick, tickInterval);
      // ensure canvas has focus so keyboard works immediately
      canvas.focus();
      updateSpeedLabel();
    }

    // Stop the game loop
    function stopGame(){
      running = false;
      if(tickTimer){
        clearInterval(tickTimer);
        tickTimer = null;
      }
    }

    // Game tick: move snake, handle collisions, food, etc.
    function gameTick(){
      if(gameOver) return;

      // Accept queued direction (prevents reversing)
      dir = nextDir;

      // Compute new head position
      const newHead = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

      // Check wall collisions
      if(newHead.x < 0 || newHead.x >= COLS || newHead.y < 0 || newHead.y >= ROWS){
        triggerGameOver('You hit the wall!');
        return;
      }

      // Check self-collision: if new head collides with any body segment
      for(let i = 0; i < snake.length; i++){
        if(snake[i].x === newHead.x && snake[i].y === newHead.y){
          triggerGameOver('You ran into yourself!');
          return;
        }
      }

      // Add new head
      snake.unshift(newHead);

      // Check if we ate food
      if(food && newHead.x === food.x && newHead.y === food.y){
        // increase score and spawn new food; do not remove tail (snake grows)
        score += 1;
        scoreEl.textContent = score;
        spawnFood();

        // Optionally, speed up slightly every few points (visual effect)
        if(score % 5 === 0 && tickInterval > 40){
          tickInterval = Math.max(40, Math.round(tickInterval * 0.9));
          // restart interval timer with new speed
          clearInterval(tickTimer);
          tickTimer = setInterval(gameTick, tickInterval);
          updateSpeedLabel();
        }
      } else {
        // Normal move: remove tail
        snake.pop();
      }

      // Draw the new frame
      render();
    }

    // Trigger game over with optional message
    function triggerGameOver(reason){
      gameOver = true;
      stopGame();
      messageEl.textContent = 'Game Over — ' + reason + ' Press Start to play again.';
      messageEl.classList.add('show', 'danger');
    }

    // Render the entire scene
    function render(){
      // Clear and draw background
      // We'll draw an even/odd grid pattern for nice look
      ctx.fillStyle = '#071226';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Draw subtle grid
      for(let y = 0; y < ROWS; y++){
        for(let x = 0; x < COLS; x++){
          if((x + y) % 2 === 0){
            ctx.fillStyle = '#071a27'; // slightly lighter
          } else {
            ctx.fillStyle = '#061320'; // slightly darker
          }
          ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
        }
      }

      // Draw food
      if(food){
        // A little rounded square for the food
        const fx = food.x * CELL_SIZE, fy = food.y * CELL_SIZE;
        ctx.fillStyle = '#ff5c5c';
        const pad = Math.max(2, CELL_SIZE * 0.12);
        roundRect(ctx, fx + pad, fy + pad, CELL_SIZE - pad*2, CELL_SIZE - pad*2, 4);
        ctx.fill();
      }

      // Draw snake segments. Head gets special color.
      for(let i = snake.length - 1; i >= 0; i--){
        const s = snake[i];
        const px = s.x * CELL_SIZE, py = s.y * CELL_SIZE;
        // Head
        if(i === 0){
          ctx.fillStyle = '#22c55e';
          roundRect(ctx, px + 1, py + 1, CELL_SIZE - 2, CELL_SIZE - 2, 4);
          ctx.fill();
          // small eye to indicate direction
          drawEye(px, py, dir);
        } else {
          // Body segments gradient
          const t = 0.3 + (i / Math.max(1, snake.length)) * 0.6;
          ctx.fillStyle = `rgba(34,197,94,${t})`;
          roundRect(ctx, px + 2, py + 2, CELL_SIZE - 4, CELL_SIZE - 4, 3);
          ctx.fill();
        }
      }
    }

    // Draw an "eye" on the head to show direction
    function drawEye(px, py, direction){
      ctx.fillStyle = '#042014';
      const r = Math.max(2, CELL_SIZE * 0.12);
      // two eyes for nicer look (compute offsets based on direction)
      let ex = px + CELL_SIZE * 0.5;
      let ey = py + CELL_SIZE * 0.45;
      if(direction.x === 1){ ex = px + CELL_SIZE * 0.7; }
      if(direction.x === -1){ ex = px + CELL_SIZE * 0.3; }
      if(direction.y === 1){ ey = py + CELL_SIZE * 0.7; }
      if(direction.y === -1){ ey = py + CELL_SIZE * 0.3; }
      ctx.beginPath();
      ctx.arc(ex, ey, r, 0, Math.PI * 2);
      ctx.fill();
    }

    // Utility: rounded rectangle path
    function roundRect(ctx, x, y, width, height, radius){
      ctx.beginPath();
      ctx.moveTo(x + radius, y);
      ctx.arcTo(x + width, y, x + width, y + height, radius);
      ctx.arcTo(x + width, y + height, x, y + height, radius);
      ctx.arcTo(x, y + height, x, y, radius);
      ctx.arcTo(x, y, x + width, y, radius);
      ctx.closePath();
    }

    // Handle keyboard input
    window.addEventListener('keydown', function(e){
      const key = e.key;
      // Map arrow keys to direction vectors
      let intended = null;
      if(key === 'ArrowUp') intended = { x: 0, y: -1 };
      else if(key === 'ArrowDown') intended = { x: 0, y: 1 };
      else if(key === 'ArrowLeft') intended = { x: -1, y: 0 };
      else if(key === 'ArrowRight') intended = { x: 1, y: 0 };
      else return; // ignore other keys

      // Prevent arrow keys from scrolling the page
      e.preventDefault();

      // Disallow immediate reverse (can't go from left to right instantly)
      if(intended && !(intended.x === -dir.x && intended.y === -dir.y)){
        // queue the direction to be applied at next tick
        nextDir = intended;
      }
    }, { passive: false });

    // Restart button
    restartBtn.addEventListener('click', function(){
      // reset timing and start
      tickInterval = BASE_TICK_MS;
      updateSpeedLabel();
      startGame();
    });

    // Speed label update
    function updateSpeedLabel(){
      if(tickInterval <= 50) speedLabel.textContent = 'Fast';
      else if(tickInterval <= 90) speedLabel.textContent = 'Normal';
      else speedLabel.textContent = 'Slow';
    }

    // Resize handling (optional): ensure crisp pixel rendering when resized by CSS
    function ensurePixelPerfect(){
      // keep internal resolution as specified in attributes: canvas.width/height already set
      // set imageSmoothingEnabled false for crispness
      ctx.imageSmoothingEnabled = false;
    }
    ensurePixelPerfect();

    // Initial render to show something before starting
    initSnake();
    spawnFood();
    render();

    // Expose a simple touch for mobile: swipe to change direction (optional)
    // Basic swipe detection
    let touchStart = null;
    canvas.addEventListener('touchstart', function(e){
      if(e.touches && e.touches.length === 1){
        touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
      }
    }, { passive: true });
    canvas.addEventListener('touchend', function(e){
      if(!touchStart) return;
      const touchEnd = e.changedTouches[0];
      const dx = touchEnd.clientX - touchStart.x;
      const dy = touchEnd.clientY - touchStart.y;
      const absX = Math.abs(dx), absY = Math.abs(dy);
      if(Math.max(absX, absY) < 20) { touchStart = null; return; } // ignore tiny taps
      if(absX > absY){
        // horizontal swipe
        if(dx > 0) nextDir = (dir.x === -1 && dir.y === 0) ? dir : { x: 1, y: 0 };
        else nextDir = (dir.x === 1 && dir.y === 0) ? dir : { x: -1, y: 0 };
      } else {
        // vertical swipe
        if(dy > 0) nextDir = (dir.y === -1 && dir.x === 0) ? dir : { x: 0, y: 1 };
        else nextDir = (dir.y === 1 && dir.x === 0) ? dir : { x: 0, y: -1 };
      }
      touchStart = null;
    }, { passive: true });

    // Bonus: allow clicking the canvas to toggle pause/resume
    canvas.style.cursor = 'pointer';
    canvas.addEventListener('click', function(){
      if(!running || gameOver){
        startGame();
      } else {
        // toggle pause
        if(tickTimer){
          clearInterval(tickTimer);
          tickTimer = null;
          messageEl.textContent = 'Paused — click to resume';
          messageEl.classList.add('show', 'ok');
        } else {
          messageEl.classList.remove('show', 'ok');
          tickTimer = setInterval(gameTick, tickInterval);
        }
      }
    });

    // Keep things accessible: focus canvas to receive keyboard events
    canvas.tabIndex = 0;

    // expose startGame on load for immediate play if desired
    // (we won't auto-start, user must click Start)
    // Optionally, start automatically after a short delay:
    // setTimeout(startGame, 500);

    // Prevent accidental drag selection on double-clicks
    canvas.addEventListener('mousedown', (e) => e.preventDefault());

    // Keyboard: space to start/restart
    window.addEventListener('keydown', (e) => {
      if(e.code === 'Space'){
        e.preventDefault();
        startGame();
      }
    });

    // Final safety: ensure initial speed label
    updateSpeedLabel();
  })();
  </script>
</body>
</html>
